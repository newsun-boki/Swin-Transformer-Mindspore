# from mindspore import Tensor
from mindspore.common.tensor import Tensor
import mindspore
import numpy as np
from mindspore.ops import operations as P
from mindspore.ops import composite as C
from scipy import special
import math
import warnings
# t = Tensor(np.arange(5))
# u = Tensor(special.erfinv(np.random.uniform(0.,1.,t.shape)))
# mul = P.Mul()
# print(u)
# tensor = mul(u,2)
# add = P.Add()
# print(tensor)
# min_value = Tensor(5, mindspore.float32)
# max_value = Tensor(20, mindspore.float32)
# x = Tensor(np.array([[1., 25., 5., 7.], [4., 11., 6., 21.]]), mindspore.float32)
# output = C.clip_by_value(x, min_value, max_value)
# print(output)

def trunc_normal_(tensor:Tensor, mean=0., std=1., a=-2., b=2.):
    def norm_cdf(x):
        # Computes standard normal cumulative distribution function
        return (1. + math.erf(x / math.sqrt(2.))) / 2.

    if (mean < a - 2 * std) or (mean > b + 2 * std):
        warnings.warn("mean is more than 2 std from [a, b] in nn.init.trunc_normal_. "
                    "The distribution of values may be incorrect.",
                    stacklevel=2)
    # Values are generated by using a truncated uniform distribution and
    # then using the inverse CDF for the normal distribution.
    # Get upper and lower cdf values
    l = norm_cdf((a - mean) / std)
    u = norm_cdf((b - mean) / std)
    tensor = Tensor(special.erfinv(np.random.uniform(2*l - 1,2*u - 1, tensor.shape)),mindspore.float32)
    # print(tensor.dtype)
    mul = P.Mul()
    tensor = mul(tensor,std * math.sqrt(2.))
    add = P.Add()
    tensor = add(tensor,mean)
    min_value = Tensor(a, mindspore.float32)
    max_value = Tensor(b, mindspore.float32)
    
    tensor = C.clip_by_value(tensor,min_value,max_value)
    return tensor
    
x = Tensor(np.array([[1,2,3,4],[5,6,7,8]]),dtype=mindspore.float32)
print(trunc_normal_(x))
print(x)